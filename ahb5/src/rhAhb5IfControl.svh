`ifndef rhAhb5IfControl__svh
`define rhAhb5IfControl__svh
/************************************************************************************/
// Author: RyanHunter
// Created: 2022-12-22 06:29:21 -0800
// Description:
// This file is automatically generated by MDC-v2, any issues found
// here should be modified in its source markdown document the same
// dir structure in Git/Obsidian/...
/************************************************************************************/

class RhAhb5IfControl #( AW=32,DW=32) extends RhAhb5IfControlBase;
	virtual RhAhb5If#(AW,DW) vif;
	`uvm_object_utils_begin(RhAhb5IfControl#(AW,DW))
	`uvm_object_utils_end
	extern virtual task driveAddressPhase(RhAhb5TransBeat b, bit waitReady);
	extern virtual task driveDataPhase(ref RhAhb5TransBeat b,output bit isError);
	extern virtual task waitDataPhase(ref RhAhb5TransBeat b,output bit isError);
	extern local task __waitHREADYSyncd__(bit val);
	extern local task __responseError__(output bit e);
	extern virtual task getResetChanged(output logic s);
	extern local function bit[AW-1:0] __calculateCurrentAddress__(RhAhb5TransBeat b);
	extern local function int __decodeHSizeToByte__(bit[2:0] hsize);
	extern virtual task sync(int cycle);
	extern virtual function uvm_bitstream_t getSignal(string signame);
	extern function  new(string name="RhAhb5IfControl");
	virtual task randomHRDATA(); vif.randomHRDATA(); endtask
	virtual task clock(int cycle=1); repeat (cycle) @(posedge vif.HCLK); endtask
	extern function logic HRESP (logic val='bz);
	extern function logic HREADY (logic val='bz);
	extern function logic HEXOKAY (logic val='bz);
	extern virtual function logic[1:0] HTRANS   (logic[1:0] val=2'hz);
	extern virtual function logic[3:0] HMASTER  (logic[3:0] val=4'hz);
	extern virtual function logic[2:0] HBURST   (logic[2:0] val=3'hz);
	extern virtual function logic[2:0] HSIZE    (logic[2:0] val=3'hz);
	extern virtual function logic[7:0] HPROT    (logic[7:0] val=8'hz);
	extern virtual function logic[`RHAHB5_DW_MAX-1:0] HWDATA(logic[`RHAHB5_DW_MAX-1:0] val='hz);
	extern virtual function logic[`RHAHB5_DW_MAX-1:0] HRDATA(logic[`RHAHB5_DW_MAX-1:0] val='hz);
	extern virtual function logic[`RHAHB5_AW_MAX-1:0] HADDR(logic[`RHAHB5_AW_MAX-1:0] val='hz);
	extern virtual function logic HMASTLOCK(logic val='bz);
	extern virtual function logic HNONSEC  (logic val='bz);
	extern virtual function logic HEXCL    (logic val='bz);
	extern virtual function logic HWRITE   (logic val='bz);
endclass

function logic RhAhb5IfControl::HWRITE(logic val='bz); // ##{{{
	if (val !== 1'bz) vif.HWRITE <= val;
	else return vif.HWRITE;
endfunction // ##}}}
function logic RhAhb5IfControl::HEXCL(logic val='bz); // ##{{{
	if (val !== 1'bz) vif.HEXCL <= val;
	else return vif.HEXCL;
endfunction // ##}}}
function logic RhAhb5IfControl::HNONSEC(logic val='bz); // ##{{{
	if (val !== 1'bz) vif.HNONSEC <= val;
	else return vif.HNONSEC;
endfunction // ##}}}
function logic RhAhb5IfControl::HMASTLOCK(logic val='bz); // ##{{{
	if (val !== 1'bz) vif.HMASTLOCK <= val;
	else return vif.HMASTLOCK;
endfunction // ##}}}
function logic[2:0] RhAhb5IfControl::HBURST(logic[2:0] val='hz); // ##{{{
	if (val !== 3'hz) vif.HBURST <= val;
	else return vif.HBURST;
endfunction // ##}}}
function logic[`RHAHB5_AW_MAX-1:0] RhAhb5IfControl::HADDR(logic[`RHAHB5_AW_MAX-1:0] val='hz); // ##{{{
	if (val !== {`RHAHB5_AW_MAX{1'bz}}) vif.HADDR <= val[AW-1:0];
	else return vif.HADDR;
endfunction // ##}}}
function logic[`RHAHB5_DW_MAX-1:0] RhAhb5IfControl::HRDATA(logic[`RHAHB5_DW_MAX-1:0] val='hz); // ##{{{
	logic [`RHAHB5_DW_MAX-1:0] rtn='h0;
	if (val !== {`RHAHB5_DW_MAX{1'bz}}) vif.HRDATA <= val[DW-1:0];
	else rtn[DW-1:0] = vif.HRDATA;
	return rtn;
endfunction // ##}}}
function logic[`RHAHB5_DW_MAX-1:0] RhAhb5IfControl::HWDATA(logic[`RHAHB5_DW_MAX-1:0] val='hz); // ##{{{
	logic [`RHAHB5_DW_MAX-1:0] rtn='h0;
	if (val !== {`RHAHB5_DW_MAX{1'bz}}) vif.HWDATA <= val[DW-1:0];
	else rtn[DW-1:0] = vif.HWDATA;
	return rtn;
endfunction // ##}}}
function logic[7:0] RhAhb5IfControl::HPROT(logic[7:0] val='hz); // ##{{{
	if (val !== 8'hz) vif.HPROT <= val;
	else return vif.HPROT;
endfunction // ##}}}
function logic[2:0] RhAhb5IfControl::HSIZE(logic[2:0] val='hz); // ##{{{
	if (val !== 3'hz) vif.HSIZE <= val;
	else return vif.HSIZE;
endfunction // ##}}}
function logic[3:0] RhAhb5IfControl::HMASTER(logic[3:0] val='hz); // ##{{{
	if (val !== 4'hz) vif.HMASTER <= val;
	else return vif.HMASTER;
endfunction // ##}}}
function logic[1:0] RhAhb5IfControl::HTRANS(logic[1:0] val=2'hz); // ##{{{
	if (val !== 2'hz) begin
		vif.HTRANS <= val;
	end else return vif.HTRANS;
endfunction // ##}}}
function logic RhAhb5IfControl::HEXOKAY(logic val='bz); // ##{{{
	if (val !== 1'bz) vif.HEXOKAY <= val;
	else return vif.HEXOKAY;
endfunction // ##}}}
function logic RhAhb5IfControl::HREADY(logic val='bz); // ##{{{
	if (val !== 1'bz) vif.HREADY <= val;
	else return vif.HREADY;
endfunction // ##}}}
function logic RhAhb5IfControl::HRESP(logic val='bz); // ##{{{
	if (val !== 1'bz) vif.HRESP <= val;
	else return vif.HRESP;
endfunction // ##}}}
task RhAhb5IfControl::driveAddressPhase(RhAhb5TransBeat b, bit waitReady);
	bit[AW-1:0] addr = __calculateCurrentAddress__(b);
	// line delay should be added here, if necessary.
	HADDR     (addr);
	HTRANS    (b.trans);
	HBURST    (b.burst);
	HWRITE    (b.write);
	HSIZE     (b.size);
	HPROT     (b.prot);
	HMASTLOCK (b.lock);
	HMASTER   (b.master);
	HNONSEC   (b.nonsec);
	HEXCL     (b.excl);
	
	if (waitReady) __waitHREADYSyncd__(1);
	else begin
		// @RyanH only when the trans is not idle, then it need wait one cycle
		if (b.trans!=0) @(posedge vif.HCLK);
	end
	
endtask
task RhAhb5IfControl::driveDataPhase(ref RhAhb5TransBeat b,output bit isError);
	vif.HWDATA <= b.data[DW-1:0];
	fork
		__waitHREADYSyncd__(1);
		__responseError__(isError);
	join_any
	disable fork;
endtask
task RhAhb5IfControl::waitDataPhase(ref RhAhb5TransBeat b,output bit isError);
	fork
		__waitHREADYSyncd__(1);
		__responseError__(isError);
	join_any
	disable fork;
endtask
task RhAhb5IfControl::__waitHREADYSyncd__(bit val);
	do
		@(posedge vif.HCLK);
	while (vif.HREADY !== val);
endtask
task RhAhb5IfControl::__responseError__(output bit e);
	do begin
		@(posedge vif.HCLK);
		e = vif.HRESP;
	end while (e==1'b0);
endtask
task RhAhb5IfControl::getResetChanged(output logic s);
	@(vif.HRESETN);
	s = vif.HRESETN;
endtask
function bit[AW-1:0] RhAhb5IfControl::__calculateCurrentAddress__(RhAhb5TransBeat b);
	bit[AW-1:0] addr;
	rhahb5_hburst_enum burst = rhahb5_hburst_enum'(b.burst);
	int byteSize = __decodeHSizeToByte__(b.size);
	addr = b.addr[AW-1:0] + byteSize*b.index;
	if (
		burst==RHAHB5_WRAP4 ||
		burst==RHAHB5_WRAP8 ||
		burst==RHAHB5_WRAP16
	) begin
		case(byteSize)
			1: addr=addr;
			2: addr[0]   = 'h0;
			4: addr[1:0] = 'h0;
			8: addr[2:0] = 'h0;
			16:addr[3:0] = 'h0;
			32:addr[4:0] = 'h0;
			64:addr[5:0] = 'h0;
			128:addr[6:0]= 'h0;
		endcase
	end
	return addr;
endfunction
function int RhAhb5IfControl::__decodeHSizeToByte__(bit[2:0] hsize);
	case (hsize)
		3'h0: return 1;
		3'h1: return 2;
		3'h2: return 4;
		3'h3: return 8;
		3'h4: return 16;
		3'h5: return 32;
		3'h6: return 64;
		3'h7: return 128;
	endcase
endfunction
task RhAhb5IfControl::sync(int cycle);
	repeat (cycle) @(posedge vif.HCLK);
endtask
function uvm_bitstream_t RhAhb5IfControl::getSignal(string signame);
	case (signame)
		"HTRANS": return vif.HTRANS;
		"HADDR": return vif.HADDR;
		"HSIZE": return vif.HSIZE;
		"HBURST": return vif.HBURST;
		"HMASTLOCK": return vif.HMASTLOCK;
		"HREADY": return vif.HREADY;
		"HWRITE": return vif.HWRITE;
		"HPROT" : return vif.HPROT;
		"HWDATA": return vif.HWDATA;
		"HRESP" : return vif.HRESP;
		"HRDATA": return vif.HRDATA;
	endcase
endfunction
function  RhAhb5IfControl::new(string name="RhAhb5IfControl");
	super.new(name);
endfunction

`endif
