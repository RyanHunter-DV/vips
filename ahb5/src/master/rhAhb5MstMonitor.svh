`ifndef rhAhb5MstMonitor__svh
`define rhAhb5MstMonitor__svh
/************************************************************************************/
// Author: RyanHunter
// Created: 2022-12-22 06:29:21 -0800
// Description:
// This file is automatically generated by MDC-v2, any issues found
// here should be modified in its source markdown document the same
// dir structure in Git/Obsidian/...
/************************************************************************************/

class RhAhb5MstMonitor#(type REQ=RhAhb5ReqTrans) extends RhMonitorBase;
	uvm_analysis_port #(REQ) reqP;
	uvm_analysis_port #(REQ) wreqP;
	uvm_analysis_port #(RhAhb5RspTrans) rspP;
	uvm_analysis_imp_selfcheckExp #(REQ,RhAhb5MstMonitor) reqI;
	RhAhb5MstConfig config;
	bit reqWriteInfo[$];
	REQ expReqQue[$];
	`uvm_component_utils_begin(RhAhb5MstMonitor)
	`uvm_component_utils_end
	extern virtual task waitResetStateChanged(input RhResetState_enum c,output RhResetState_enum s);
	extern virtual task mainProcess();
	extern local task reqMonitor();
	extern local function void __reqSelfCheck__(REQ act);
	extern local task __waitRequestValid();
	extern local function void __collectAddressPhaseInfo(ref REQ r);
	extern local task __collectWriteData(ref REQ r);
	extern local task rspMonitor();
	extern local task __waitReadyHigh();
	// extern local task __protocolCheck__ (REQ _tr);
	extern virtual function void build_phase(uvm_phase phase);
	extern function  new(string name="RhAhb5MstMonitor",uvm_component parent=null);
	extern virtual function void connect_phase(uvm_phase phase);
	extern virtual task run_phase(uvm_phase phase);
	extern virtual function void write_selfcheckExp(REQ _tr);
endclass
task RhAhb5MstMonitor::waitResetStateChanged(input RhResetState_enum c,output RhResetState_enum s);
	logic sig = logic'(c);
	config.getResetChanged(sig);
	s = RhResetState_enum'(sig);
endtask
task RhAhb5MstMonitor::mainProcess();
	
	fork
		reqMonitor();
		rspMonitor();
	join
endtask
task RhAhb5MstMonitor::reqMonitor();
	forever begin
		REQ req=new("req");
		`rhudbgCall("",__waitRequestValid())
		`rhudbgCall("",__collectAddressPhaseInfo(req))
		reqWriteInfo.push_back(req.write);
		`rhudbg($sformatf("send packet to reqP\n%s",req.sprint()))
		reqP.write(req);
		if (req.write==1) begin
			__collectWriteData(req);
			`rhudbg($sformatf("send packet to wreqP,with wdata\n%s",req.sprint()))
			wreqP.write(req);
		end else config.waitCycle();
		__reqSelfCheck__(req);
	end
endtask
function void RhAhb5MstMonitor::__reqSelfCheck__(REQ act);
	REQ exp;
	`rhudbg("starting self checking ...")
	if (expReqQue.size()==0) begin
		`uvm_fatal("SELFCHECK","no expected transaction should be sent by this VIP")
		return;
	end
	exp = expReqQue.pop_front();
	if (exp.compare(act))
		`uvm_fatal("SELFCHECK",$sformatf("driver/monitor req compare FAILED, trans to be sent is\n%s\ntrans collected is\n%s",exp.sprint(),act.sprint()))
	else
		`rhudbg($sformatf("driver/monitor req compare PASSED, driver has sent an expected transaction\n%s",act.sprint()))
	return;
endfunction
task RhAhb5MstMonitor::__waitRequestValid();
	bit done = 1'b0;
	string _file;int _line;
	`caller0(_file,_line)
	`rhudbg($sformatf("__waitRequestValid called by(%0s,%0d)",_file,_line))
	do begin
		// if (config.getSignal("HTRANS") && config.getSignal("HREADY")) done = 1'b1;
		logic[1:0] htrans = config.ifCtrl.HTRANS;
		//for debug, `rhudbg($sformatf("monitored HTRANS: %bb",htrans))
		// if ((htrans==1||htrans==2||htrans==3) && config.ifCtrl.HREADY===1) done = 1'b1;
		if ((htrans==1||htrans==2||htrans==3)) done = 1'b1;
		else config.waitCycle();
	end while (!done);
endtask
function void RhAhb5MstMonitor::__collectAddressPhaseInfo(ref REQ r);
	r.trans = config.ifCtrl.HTRANS;
	r.burst = config.ifCtrl.HBURST;
	r.addr  = config.ifCtrl.HADDR;
	r.size  = config.ifCtrl.HSIZE;
	r.prot  = config.ifCtrl.HPROT;
	r.master= config.ifCtrl.HMASTER;
	r.lock  = config.ifCtrl.HMASTLOCK;
	r.write = config.ifCtrl.HWRITE;
	r.nonsec= config.ifCtrl.HNONSEC;
	r.excl  = config.ifCtrl.HEXCL;
endfunction
task RhAhb5MstMonitor::__collectWriteData(ref REQ r);
	config.waitCycle();
	// r.wdata = config.getSignal("HWDATA");
	r.wdata = config.ifCtrl.HWDATA;
endtask
task RhAhb5MstMonitor::rspMonitor();
	forever begin
		RhAhb5RspTrans rsp=new("rsp");
		wait(reqWriteInfo.size()); // need wait last cycle has request.
		`rhudbgCall("rspMonitor: waiting for ready high",__waitReadyHigh())
		rsp.resp  = config.ifCtrl.HRESP;
		rsp.exokay= config.ifCtrl.HEXOKAY;
		rsp.iswrite = reqWriteInfo.pop_front();
		// if (rsp.iswrite==0 && rsp.resp==0) rsp.rdata = config.getSignal("HRDATA");
		if (rsp.iswrite==0 && rsp.resp==0) rsp.rdata = config.ifCtrl.HRDATA;
		rspP.write(rsp);
	end
endtask
task RhAhb5MstMonitor::__waitReadyHigh();
	bit done=1'b0;
	while (!done) begin
		// done = (config.getSignal("HREADY")[0]==1'b1)? 1'b1 : 1'b0;
		done = (config.ifCtrl.HREADY===1'b1)? 1'b1 : 1'b0;
		config.ifCtrl.clock();
	end
endtask
function void RhAhb5MstMonitor::build_phase(uvm_phase phase);
	super.build_phase(phase);
	reqP = new("reqP",this);
	rspP = new("rspP",this);
	wreqP= new("wreqP",this);
	reqI = new("reqI",this);
endfunction
function  RhAhb5MstMonitor::new(string name="RhAhb5MstMonitor",uvm_component parent=null);
	super.new(name,parent);
endfunction
function void RhAhb5MstMonitor::connect_phase(uvm_phase phase);
	super.connect_phase(phase);
endfunction
task RhAhb5MstMonitor::run_phase(uvm_phase phase);
	super.run_phase(phase);
endtask

// task RhAhb5MstMonitor::__protocolCheck__(REQ _tr);
// 	// wait config.ifCtrl.HTRANS == RHAHB5_NONSEQ
// 	REQ _c = new("tr");
// 	do
// 		config.ifCtrl.clock();
// 	while (config.ifCtrl.HTRANS!==RHAHB5_NONSEQ);
// 
// endtask

function void RhAhb5MstMonitor::write_selfcheckExp(REQ _tr);
	`rhudbg($sformatf("get the exp req:\n%s",_tr.sprint()))
	// fork __protocolCheck__(_tr); join_none
	expReqQue.push_back(_tr);
endfunction

`endif
